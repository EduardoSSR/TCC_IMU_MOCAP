%\part{Referencial Teórico}

\chapter[Referencial Teórico]{Referencial Teórico}

\section{Prevenção de Lesões}

O desempenho máximo de atletas pode ser afetado por lesões musculoesqueléticas, fazendo com que seus resultados não sejam os melhores, impedindo de participar em competições ou causando a saída do esporte precocemente. O estudo do corpo humano permite obter uma análise operacional dos atletas, ou seja, demonstrar diferentes parâmetros, tais como do sistema proprioceptivo, da estabilidade articular e da força muscular durante movimentos específicos, a mecânica dos tecidos biológicos utilizados no esporte, bem como do estudo morfofuncional dos atletas. Podendo assim promover a prevenção de lesões \cite{miziara2014}.  

O esforço físico feito pelo atleta durante práticas esportivas lhes proporcionam diversas consequências fisiológicas. O ramo do conhecimento dedicado ao estudo de efeitos fisiológicos agudos e crônicos dos exercícios físicos sobre os diversos sistemas corporais é a Fisiologia do Exercício. Contudo, os métodos de medição ou determinação destes estados do corpo humano em pleno emprego do seu esforço são importantes para diagnosticar e prevenir lesões, fortalecimento de musculatura e tendões, ou seja, todo o desempenho do atleta \cite{rocha2005}.

Estes métodos utilizados analisam algumas características importantes, tais como velocidade, aceleração, posicionamento no espaço e necessitam, de certa maneira, mais do que um profissional com olhar treinado para uma análise real do movimento do corpo humano, dado que a prevenção de lesões e o desempenho dos atletas estão ligados à biomecânica esportiva deles \cite{amadio2000}.

Dessa forma, as avaliações biomecânicas devem ir além do olhar clínico ao analisar os parâmetros associados a lesões de atletas e estruturarem seus argumentos em sistemas que possam ser capazes de traduzir estes parâmetros \cite{miziara2014}. Os métodos utilizados para estudar as diversas formas de movimento são: eletromiografia, antropometria, dinamometria, cinemetria \cite{amadio2007}.

A eletromiografia é a medição da atividade elétrica de músculos que estão sendo utilizados durante a prática esportiva. A antropometria estabelece as propriedades físicas do corpo humano estudado como as medidas geométricas. A dinamometria mede parâmetros como força e distribuição de pressão com equipamentos específicos para cada atividade física. E, por fim, a cinemetria utiliza parâmetros como posição e orientação de partes do corpo humano, que é o tipo de medição tratado neste trabalho \cite{amadio2007}\cite{medeiros2013}.

\section{O processo de amostragem}
 
A cinemetria pode ser realizada através da captura por imagens ou da medição de determinados pontos com sensores inerciais. E para os dois métodos é preciso saber qual a frequência de amostragem, no caso das imagens, o número de \textit{frames} por segundo, necessários para captar o movimento com precisão suficiente para afirmar que ele representa o deslocamento real \cite{amadio2007}.

Para definição dessa frequência existe o teorema de amostragem Nyquist-Shannon, que é a base para determinar a frequêcia mínima de amostragem de um sinal. Através do processo de amostragem, um sinal contínuo no tempo, é modificado para um sinal discreto no tempo. O teorema da amostragem assegura que as amostras discretas uniformemente espaçadas são uma representação completa do sinal, se sua frequência máxima é menor do que a metade da taxa de amostragem \cite{madeiro2011}.  

Para formalizar o conceito, seja $ x(t) $ um sinal contínuo no tempo e $ X(f) $ sua transformada de Fourier (ou seja, representação do sinal em frequência):

\begin{equation}
 X(f) = \int^{\infty}_{-\infty} x(t)e^{-i2\pi ft}dt 
\end{equation}

O sinal $x(t)$ é limitado em banda, B, se:
\begin{equation}
X(f) = 0 \; \;\forall \; \; |f|>B
\end{equation}

A condição suficiente para uma exata reconstrução a partir das amostras em uma taxa de amostragem uniforme $ f_{s} $ (em amostras por unidade de tempo) é:

\begin{equation}
f_{s}>2B 
\end{equation}

$2B$ é a chamada de Taxa de Nyquist e é uma propriedade do sinal limitado em banda, e $f_{s}/2$ é chamado de Frequêcia de Nyquist e é um propriedade desse sistema de amostragem.

O tempo T entre as sucessivas amostras é o intervalo de amostragem.

\begin{equation}
T=\frac{1}{f_{s}}
\end{equation}

O teorema da amostragem garante que é possível a reconstrução exata do sinal $ x(t) $ original desde que sejam respeitadas as condições iniciais \cite{willsky2010}.

A velocidade do movimento humano varia de  acordo o do local analisado. Pode ser a velocidade do corpo inteiro, ou de órgãos separadamente. Esta velocidade pode ser medida em frequência e varia entre 10 e 160 Hz \cite{song2016}.

Logo a Taxa de Nyquist para amostragem de sinais de movimento humano é de 320 Hz. E o sensor para medir os movimentos deve ter uma frequência de amostragem maior que essa \cite{song2016}. 


	\section{MEMS}

		MEMS (\textit{Micro Electro Mechanical Systems} - Sistemas Microeletromecânicos) é uma tecnologia de processamento usada para criar dispositivos integrados ou sistemas que combinam componentes mecânicos e elétricos. Eles são fabricados usando técnicas de processamento em lote de circuitos integrados e podem variar em tamanho entre alguns micrômetros para milímetros. Esses dispositivos (ou sistemas) têm a capacidade de detectar, controlar e atuar na escala micro e gerar efeitos em escala macro \cite{prime2002}. 

		O termo MEMS, é um acrônimo originado nos Estados Unidos. Também é conhecido como \textit{Microsystems Technology} (MST) na Europa e \textit{Micromachines} no Japão. Independentemente da terminologia, o fator que define um dispositivo MEMS está na maneira como é feito. Enquanto os aparelhos eletrônicos são fabricados usando tecnologia IC (\textit{Integrated Circuit} - \textit{chip} de computador), os componentes micromecânicos são fabricados por sofisticadas manipulações com silício e outros substratos usando processos de microusinagem. Processos como microusinagem a granel e de superfície, bem como micromaquinação de alta proporção (HARM - \textit{High Aspect Ratio Micromachining}) remove seletivamente partes do silício ou adiciona camadas estruturais adicionais para formar os componentes mecânicos e eletromecânicos. Enquanto circuitos integrados são projetados para explorar as propriedades elétricas do silício, os MEMS aproveitam as propriedades mecânicas do silício ou suas propriedades elétricas e mecânicas \cite{prime2002}.

		Na forma mais geral, os MEMS consistem em microestruturas mecânicas, microssensores, microatuadores e microeletrônica, todos integrados no mesmo \textit{chip} de silício (Figura \ref{esquematico_mems}). Microsensores detectam mudanças no ambiente do sistema medindo informações ou fenômenos mecânicos, térmicos, magnéticos, químicos ou eletromagnéticos. A microeletrônica processa essa informação e sinaliza aos microatuadores para reagirem e criarem alguma forma de mudanças no meio ambiente \cite{prime2002}.

		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.7
			]{figuras/esquematico_mems.png}
			\caption{Ilustração esquemática de componentes MEMS}
			Fonte: \cite{prime2002}
			\label{esquematico_mems}
		\end{figure}

		Os dispositivos MEMS são extremamente pequenos, seus componentes são geralmente microscópicos (Figura \ref{escala_mems}). Alavancas, engrenagens, pistões, motores e até motores a vapor foram todos fabricados por MEMS. No entanto, a tecnologia MEMS não se refere apenas à miniaturização de componentes mecânicos ou à fabricação de coisas a partir do silício (na verdade, o termo MEMS é enganoso, já que vários dispositivos micromaquinados não são mecânicos em nenhum sentido). MEMS é uma tecnologia de fabricação, um paradigma para projetar e criar dispositivos e sistemas mecânicos complexos, bem como sua eletrônica integrada, utilizando técnicas de fabricação em lote \cite{prime2002}.

		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.5
			]{figuras/escala_mems.png}
			\caption{Um motor MEMS ao lado de uma fio de cabelo humano.}
			Fonte: \cite{prime2002}
			\label{escala_mems}
		\end{figure}

	\section{IMU}

		A história do sensor IMU começou em 1930, quando foi usado para auxiliar a navegação de aeronaves e outros dispositivos de grande porte. Por causa de suas restrições, principalmente em tamanho, custo e consumo de energia, o uso do IMU naquele momento era restrito a aplicações em dispositivos grandes e, portanto, impopular para equipamentos de tamanho menor e em grande escala de consumo. Porém, recentemente, o sensor IMU feito por MEMS foi introduzido com uma característica atraente de baixo custo e com poder de processamento. A demanda aumentou e as áreas de aplicação também. Atualmente, diversos fabricantes estão competindo nos melhores projetos de IMU, como \textit{Invensense, Honeywell, STMicroelectronics, Microstrain e X-Sens} \cite{ahmad2013}.
		
		Os sensores de IMU podem ser capazes de medir diversas variáveis. Os mais comuns são feitos para medir 6 graus de liberdade. São 3 medidas de aceleração linear a partir de um acelerômetro e 3 medidas de aceleração angular feitas por um giroscópio (Figura \ref{eixos_imu}) \cite{santos2016}.
		 
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.8]{figuras/Eixos_imu.png}
			\caption{Eixos de orientação. Adaptada de \citeonline{mpu6050}.}
			\label{eixos_imu}	
		\end{figure}


		A vantagem de usar este tipo de IMU é que não será interferido pelo campo magnético externo em torno do
		sensor quando é usado próximo demais de material ferromagnético. Por outro lado, dependendo do acelerômetro e do giroscópio, pode não ser suficiente para aumentar a precisão da medição devido ao ruído dos sensores e à questão do desvio do giroscópio. Os dados adquiridos pelo IMU são integrados como mostrado na Figura \ref{integracao_imu} \cite{ahmad2013}.

		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.5
			]{figuras/integracao_imu.png}
			\caption{Sensor inercial baseado em 2 sensores}
			Fonte: \cite{ahmad2013}
			\label{integracao_imu}
			
		\end{figure}

		Com essas variáveis adquiridas um padrão de movimento pode ser traçado, bem como podem ser feitas análises sobre o movimento humano. Assim, junto com a sEMG (\textit{Surface Electromyography} - Eletromiografia de Superfície), o uso de sensores inercias tem sido mais solicitado na área de monitoramento de práticas esportivas \cite{howard2016}.
		
		Porém, a utilização de IMUs com equipamentos de comunicação sem fio, têm mostrado uma certa vantagem sobre o uso de sensores com sEMG. Isso ocorre por conta de a integração entre acelerômetros, giroscópios e dispositivos de transmissão sem fio ser mais simplificada do que a aquisição de dados por eletromiógrafos sem fio \cite{howard2016}. 
		
		Os testes que foram feitos com uso de sensores inerciais, segundo  Howard (2016) foram capazes de produzir dados relacionados com fadiga muscular, desempenho, postura e velocidade. O que possibilita melhores técnicas de treinamento e até mesmo prevenção de lesão.

			\subsection{Acelerômetro}
			
				Os sensores de movimento são feitos para aferir taxa de variação de posição, ou seja, o deslocamento que estiver ocorrendo. Assim, se a posição, $x(t)$, de um corpo varia ao longo tempo, então será obtida sua velocidade, $v(t)$,  derivando essa mudança de posição ao longo do tempo como mostra a Equação \ref{equvelocidade}. A Equação \ref{equacel} mostra que ao derivar a variação de velocidade ao longo do tempo será calculada a aceleração, $a(t)$, do corpo \cite{moyses2013}.
				\begin{equation}
				v(t) = \frac{dx(t)}{dt}
				\label{equvelocidade}
				\end{equation}
				
				\begin{equation}
				a(t) = \frac{dv(t)}{dt} = \frac{d^2x(t)}{dt^2} 
				\label{equacel}
				\end{equation}
				
				Um acelerômetro é capaz de medir a aceleração, e a partir desse dado é possível obter, também, a velocidade e a posição. Basta fazer a operação inversa da derivada, que pode ser vista nas Equações \ref{intvel} e \ref{intpos} \cite{moyses2013}.
				
				\begin{equation}
				v(t) = v(0) + \int_{0}^{1}(a(t)dt)
				\label{intvel}
				\end{equation}
				\begin{equation}
				x(t) = x(0) + \int_{0}^{1}(v(t)dt)
				\label{intpos}
				\end{equation}
				
				Acelerômetros podem ser utilizados em muitas áreas, como na  automotiva (com \textit{airbags}), na navegação, no monitoramento de máquinas, na saúde, nos jogos e em outras. São diversos os processos físicos utilizados para desenvolver um sensor para medir a aceleração. Em aplicações que envolvem voo, aviões e satélites,
				acelerômetros são baseados em propriedades de massas rotativas. Na indústria,
				porém, o projeto mais comuns são feitos a partir da combinação da Lei de Newton de
				aceleração de massa e a Lei de Hooke de ação de mola \cite{carneiro2003}.
				
				Existem os que funcionam a partir do efeito de cristais piezoelétricos, que é o princípio no qual alguns cristais geram uma corrente elétrica como resposta a uma pressão mecânica. Então, o acelerômetro  funciona como na Figura \ref{acel} demonstra, como uma pequena caixa com uma esfera dentro, e as paredes são os cristais piezoelétricos.  Sempre que a caixa é alterada de posição a esfera é forçada a se mover em direção de uma das paredes devido a força da gravidade ou de qualquer outra força de aceleração em outro sentido que não a normal. Cada par de paredes paralelas correspondem a um eixo no espaço. Assim, a partir da corrente gerada em cada parede é possível determinar a direção do movimento acelerado e sua magnitude \cite{Sanjeev2018}.
				
				\begin{figure}[h!]
					\centering
					\includegraphics[keepaspectratio=true,scale=0.8
					]{figuras/acelerometro.PNG}
					\caption{Princípio de funcionamento do acelerômetro. Adaptada de \citeonline{Sanjeev2018}.}
					
					\label{acel}
				\end{figure}
	
		\subsection{Giroscópio}
			
			Os giroscópios , também, são sensores de movimento, porém eles não medem aceleração linear como os acelerômetros, eles disponibilizam ao usuário a velocidade angular de um objeto em torno de um eixo. Em geral, os giroscópios feitos com tecnologia MEMS utilizam do efeito Coriolis, no qual um objeto que se encontra em um movimento de rotação imprime na massa um deslocamento ortogonal a direção de rotação. Os giroscópios têm um princípio bem mais complexo que os acelerômetros. Este é um dos motivos fizeram que eles demorarem mais a parecer como dispositivos MEMS \cite{almeida2014}.
			
			O giroscópio do tipo diapasão é constituído por duas massas paralelas que oscilam com a mesma amplitude, direção igual e sentidos opostos mostrado na Figura \ref{gyro}.
			
			\begin{figure}[h!]
				\centering
				\includegraphics[keepaspectratio=true,scale=0.7
				]{figuras/diapasao.png}
				\caption{ Imagem de microscopia eletrônica por varredura de um giroscópio diapasão.}
				Fonte: \cite{forhan2010}
				\label{gyro}	
			\end{figure}
			
			Ao acontecer uma rotação, a força de Coriolis gera uma vibração ortogonal ao sentido do movimento de cada massa. A amplitude desse movimento pode ser medido de forma capacitiva. A utilização de dois giroscópios na mesma direção e em sentidos opostos aumenta a precisão da medição. Com a medida da força de Coriolis  $F_{c}$, a medida da massas paralelas $m$, se movendo a um determinada velocidade $v$, com relação a um referencial fixo que possua uma velocidade angular $ \omega $ é possível obter a aceleração de Coriolis $a_{c}$ como mostram as Equações \ref{calFc} e \ref{calA} \cite{forhan2010}.
			
			\begin{equation}
			F_{c} = 2mv\omega
			\label{calFc}
			\end{equation}
			
			\begin{equation}
			a_{c} = 2v\omega
			\label{calA}
			\end{equation}
			
			Com aceleração de Coriolis, que é obtido pelo sensor, a unidade de processamento do sensor é capaz de calcular a velocidade angular em $\degree$/s. Com a velocidade angular em relação a cada eixo do espaço tridimensional sendo obtida, é possível encontrar posição angular do sensor e do objeto, ou corpo, em que ele estiver acoplado \cite{forhan2010}\cite{moyses2013}. 
			
			A unidade de medida padrão de velocidade angular  é rad/s. Então, com o intuito de converter o valor obtido para o padrão internacional, tem-se as Equações \ref{conv1}, \ref{conv2}, \ref{conv3} e \ref{conv4}:
			
			\begin{equation}
			1 \pi rad = 180\degree
			\label{conv1}
			\end{equation}
			
			\begin{equation}
			1 \pi rad /s = 180\degree/s 
			\label{conv2}
			\end{equation}
			
			\begin{equation}
			 \frac{\pi}{180} rad /s = (\frac{180}{180})\degree/s 
			\label{conv3}
			\end{equation}
			
			\begin{equation}
			\frac{\pi}{180} rad /s = 1\degree/s 
			\label{conv4}
			\end{equation}

%Os giroscópios são similares em operação aos acelerômetros; no entanto, eles são usados ​​para detectar a velocidade angular, geralmente com uma saída de graus por segundo. Essa funcionalidade os torna muito úteis em conjunto com acelerômetros para um sistema que requer rastreamento de movimento confiável.

\subsection{MPU6050}
	
	O MPU6050, da séria MPU60X0, foi a primeira interface de movimento a integrar 6 eixos de leitura em um dispositivo único. Esse sensor de movimento, integra 3 eixos de um acelerômetro e 3 eixos de um giroscópio e um DMP (\textit{Digital Motion Processor} - Processador Digital de Movimento) tudo em um pequeno componente medindo 4x4x0.9mm. As suas principais qualidades são seu tamanho reduzido, o baixo consumo de energia, a alta precisão e confiabilidade, a alta tolerância a choques mecânicos, ter seu desempenho programável para aplicações específicas e ainda um baixo custo \cite{mpu6050}.
	
	O protocolo de comunicação utilizado pelo MPU6050 é o $I^2C$ (\textit{Inter-Integrated Circuit} - Circuito Inter-Integrado). Que é um protocolo de barramento, e com os mesmos dois fios podem ser conectados vários dispositivos, um sendo o \textit{master} e os outros como \textit{slave}. Esta é uma característica boa para reduzir a quantidade de pinos necessários para conexão de mais dispositivos no microcontrolador \cite{mpu6050}.
	
	As aplicações sugeridas pelo fabricante para o MPU6050 são diversas. Abaixo estão listadas algumas:
	\begin{itemize}
		\item Tecnologia \textit{ BlurFree\texttrademark }\footnote{Para estabilização de imagens e videos.};
		\item Controles para jogos baseados em movimento;
		\item Sensores em roupas \textit{TouchAnywhere} para aplicação na saúde e esportes;
		\item Tecnologia \textit{ MotionCommand\texttrademark}\footnote{Para comandos de movimento curtos.}; 
		\item Em brinquedos
	\end{itemize}
	
	\begin{description}
		\item[Características do MPU6050]  
		\item \begin{itemize}	 
		
		\item O giroscópio MEMS de 3 eixos do MPU6050, possui as seguintes características segundo \citeonline{mpu6050}:
			\begin{itemize}
				\item Saídas digitais com os valores de velocidade angular para os eixos X,Y e Z com escalas programáveis entre $ \pm250 $,$ \pm500 $,$ \pm1000 $ e $ \pm 2000$ $\degree$/seg;
				\item Conversores ADCs (\textit{Analog Digital Converter} - Conversor Analógico Digital) de 16 bits integrados permitem amostragem simultânea do giroscópio
				\item Corrente de operação: 3.6mA;
				\item Bom desempenho com ruído de baixa frequência;
				\item Filtro passa-baixa programável;
				\item Fator de escala de sensibilidade calibrado de fábrica.
			\end{itemize}
			
		\item O acelerômetro MEMS de 3 eixos do MPU6050, possui as seguintes características segundo \citeonline{mpu6050}:
			\begin{itemize}
				\item Saídas digitais dos 3 eixos do acelerômetro com escalas programáveis entre $\pm2g$, $\pm4g$, $\pm8g$ e $\pm16g$. Sendo \textquoteleft$ g$\textquoteright \ uma constante que equivale a aceleração da gravidade\footnote{aproximadamente $9,81 m/s^2 $.};
				\item Conversores ADCs de 16 bits integrados permitem amostragem simultânea do acelerômetro sem a necessidade de um multiplexador;
				\item Orientação, detecção e sinalização.
				
			\end{itemize}
		\end{itemize}
	\end{description}
	
	
	

\subsection{Arduíno}

O Arduíno é uma plataforma de desenvolvimento de código aberto que contém elementos de \textit{hardware} e \textit{software} especificamente adaptados à simplicidade de uso, permitindo uma rápida prototipagem. Placas Arduíno têm grande potencial de desenvolvimento e uma ampla gama de recursos para uso em conjunto com sensores, transceptores de dados e atuadores, os quais são de grande interesse para este projeto \cite{smith2016}.

Uma das maiores vantagens do Arduíno sobre outras plataformas de prototipagem com microcontroladores é a facilidade para utilizá-la, que permite que pessoas que não necessariamente são da área de tecnologia, possam aprender rapidamente o básico e criar seus próprios projetos. E existe um grande compartilhamento de projetos de forma livre utilizando essa plataforma. Isso é relevante para esse projeto em específico, pois ele está sendo desenvolvido para utilização de pesquisadores de diversas áreas do conhecimento, os quais poderão aprender a adaptar o projeto para suas necessidades e demandas futuras \cite{arduino2011}.

Existem diversos modelos de placas Arduíno no mercado, sendo as mais utilizadas Lilypad, Uno, Mini Pro, Mega e Nano. Cada uma dessas placas possuem suas particularidades em relação ao número de recursos, formato físico, memória e capacidade de processamento. Na Tabela \ref{tipos_arduino} estão listados alguns modelos e suas características \cite{smith2016}.


\begin{table}[h!] \footnotesize
	\centering
	\caption{Tabela de comparação dos modelos de Arduíno. Adaptado de \citeonline{smith2016}.}
	\label{tipos_arduino}
	
	\begin{tabular}{lccccc}
		\toprule
		\textbf{Modelos} & \textbf{Lilypad} & 
		\textbf{Uno} & \textbf{Pro} & \textbf{Mega}  & \textbf{Nano} \\
		\midrule
		Microcontrolador & ATmega32u4 & ATmega328P & ATmega238 & ATmega2560 & ATmega328P \\
		Tensão de Operação & 3.3V & 5V & 3.3/5V & 5V & 5V \\
		Tensão de Entrada & 3.8-5V & 7-12V & 5-12V & 7-12V & 5-12V \\
		Pinos Digitais & 9 & 14 & 14 & 54 & 14 \\
		Entradas Analógicas & 4 & 6 & 6 & 16 & 8 \\
		Memória Flash & 32kB & 32kB & 32kB & 256kB & 32kB \\
		Velocidade do Clock & 8MHz & 16MHz & 8/16MHz & 16MHz & 16MHz \\
		Dimensões Físicas & 50mm$\oslash$ & 68.6 x 53.4mm & 52 x 53mm & 101.5x53.5mm &  18,5 x 43,2mm \\
		Custo Aproximado & R\$ 22,00 & R\$ 54,00 &  R\$ 50,00 & R\$ 80,00 & R\$ 24,00 \\
		\bottomrule
		%Fonte adaptada: & \cite{smith2016}
	\end{tabular}
\end{table}

O Arduíno Nano (Figura \ref{arduino}) tem funcionalidades  semelhantes às do Arduíno Duemilanove, mas com um formato diferente. O Nano possui o microcontrolador ATmega328P embutido, o mesmo que o Arduíno UNO. A principal diferença entre eles é que a placa UNO é apresentada em formato PDIP (\textit{Plastic Dual-In-line Package}) com 30 pinos e Nano está disponível em PQFP (\textit{Plastic Quad Flat Pack}) com 32 pinos. Os 2 pinos extras do Arduno Nano servem para as funcionalidades do ADC, enquanto o UNO possui 6 portas ADC, o Nano possui 8. A placa Nano não vem com um conector para fonte DC (\textit{Direct Current} - Corrente Contínua) como outras placas Arduíno, mas possui uma porta mini-USB. Esta porta é usada para programação, monitoramento serial e alimentação (se necessário). A característica mais fascinante do Nano é que ele escolherá a fonte de energia com maior diferença de potencial, e o \textit{jumper} de seleção de fonte de energia não precisa ser utilizado \cite{john2018}.  

\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.77
	]{figuras/arduino_nano.png}
	\caption{ Arduino Nano }
	Fonte: \cite{john2018}
	\label{arduino}	
\end{figure}

Para se comunicar com qualquer microcontrolador ou computador, é necessário usar uma linguagem de programação. No caso do Arduíno, é necessário usar a linguagem C++\footnote{Com alguma modificações.}, que é uma linguagem tradicional e já bastante conhecida. Porém, essa linguagem ainda não é a que a máquina compreende, é uma linguagem de alto nível, e para a máquina compreendê-la é necessário o uso de um compilador, que converte a linguagem de alto nível para a linguagem de máquina. Em geral, para compilar um programa, é necessário a utilização de um IDE (\textit{Integrated Development Environment} - Ambiente de Desenvolvimento Integrado), um aplicativo de computador que possui um compilador integrado. A plataforma do Arduíno utiliza o Arduíno IDE \cite{chavier2016}. 

\subsection{Esp8266}

O ESP8266 é  um microcontrolador  fabricado pela empresa \textit{Espressif Systems}. Possui um sistema de comunicação \textit{Wi-Fi }próprio, podendo ser utilizado tanto para acessar a uma rede existente, como para criar o próprio ponto de acesso.  Essa funcionalidade é seu grande diferencial em relação ao Arduíno, porém existem outras diferenças \cite{oliveira2017}. 

A tensão das portas digitais é de 3,3 V, possui apenas uma porta para leitura analógica, 11 portas digitais, memória \textit{flash} de 4Mb e o processador com velocidade de \textit{clock} de 80MHz, todas essas características são diferentes nas placas Arduíno \cite{wemos2017}.

Existe uma grande variedade de placas disponíveis no Brasil.  Mas em todas elas é utilizado o mesmo processador ESP8266. O que distingue os modelos um do outro é o número de pinos GPIO (\textit{General Purpose Input/Output - Entrada e Saída para Uso Geral}) expostos, a quantidade de memória \textit{flash} fornecida, o estilo dos pinos do conector e várias outras considerações relacionadas à fabricação.  Em relação a  programação, elas são todas iguais e podem ter seu código embarcado escrito com a IDE do Arduíno, sendo apenas necessário carregar sua biblioteca de placas, através do próprio programa, e a linguagem de programação utilizada é o C++  \cite{kolban2016}.

Um dos modelos é a placa Wemos D1 (Figura \ref{wemosd1} ), que tem o mesmo formato do Arduíno UNO, o que deixa a utilização mais confortável para usuários do Arduíno. Esse modelo possui todos os seus pinos descritos na própria placa, também possui pinos para comunicação $I^2C$, conector micro USB e um conector de carga que aceita tensão entre 9 e 24 V \cite{kolban2016}\cite{wemos2017}.

\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio=true,scale=0.7
	]{figuras/wemosd1.png}
	\caption{ WeMos D1 - R2 }
	Fonte: \cite{wemos2017}
	\label{wemosd1}	
\end{figure}

\section{\textit{Python}}

\textit{Python} é uma linguagem de programação poderosa, mas fácil de usar, desenvolvida por Guido van Rossum, em 1991. Com o \textit{Python}, você pode escrever rapidamente um pequeno projeto e também, por se adaptar bem, pode ser usado para aplicativos comerciais. Uma prova de como é uma linguagem comercial é ela ser utilizada por empresas como \textit{Google}, IBM, NASA, \textit{Xerox, Yahoo} e outras grandes empresas \cite{dawson2010}.

O principal objetivo de qualquer linguagem de programação é fazer uma ponte entre o programador e a máquina. E a maioria das linguagens de programação tornam essa comunicação mais próxima da humana, mas o \textit{Python} é tão direto que, segundo DAWSON (2010), é chamada de "programação na velocidade do pensamento". Essa facilidade se traduz na alta produtividade de programadores profissionais os quais com ele conseguem fazer programas mais curtos e mais rápidos de escrever do que com outras linguagens de programação. 

\textit{Python} é uma boa linguagem para aplicações científicas porque é fácil traduzir raciocínio em algoritmos através dela, bem como é simples ler um código em \textit{Python} e conseguir entender o raciocínio por trás dele, por ser uma linguagem com poucos caracteres especiais, poucas palavras chaves utilizadas apenas para compilar e ter uma sintaxe muito próxima da linguagem falada \cite{reitz2018}. Além disso, é uma linguagem de propósito geral. Muitas vezes, é necessário lidar com tarefas laterais: buscar dados em um banco de dados remoto, ler uma página na internet, exibir graficamente os resultados, criar uma planilha, etc. Linguagens de cunho especificamente científico têm um sério problema aí, mas, uma vez que \textit{Python} é utilizada em praticamente todos os tipos de tarefa, encontram-se módulos prontos para realizar essas tarefas que podem se tornar complicadas. Ou seja, é uma preocupação a menos para quem está desenvolvendo aplicações científicas \cite{downey2012}.
  
%\section {Video \textit{Tracker}}
%Video \textit{tracker} \cite{onorato2012}

\section{Protocolo HTTP}

\textit{Hypertext Transfer Protocol} (HTTP)  é o método utilizado para enviar e receber informações na \textit{web}.  A versão mais utilizada atualmente é a 1.1, definida pela especificação RFC 2616. RFCs (\textit{Request for Comments}) são documentos técnicos desenvolvidos e mantidos pelo IETF (\textit{Internet Enginnering Task Force}), instituição que especifica os padrões que serão implementados e utilizados em toda a internet \cite{vieira2007}.

 O protocolo é baseado em requisições e respostas entre clientes e servidores. O cliente, navegador ou dispositivo que fará a requisição (também é conhecido como \textit{user agent}), solicita um determinado  \textit{resource} (recurso) enviando um pacote de informações contendo alguns cabeçalhos (\textit{headers}) a um URI (\textit{Uniform Resource Identifier} - Identificador Uniforme de Recurso ) ou, mais especificamente, URL (\textit{Uniform Resource Locator} - Localizador Uniforme de Recursos). O servidor recebe estas informações e envia uma resposta, que pode ser um recurso ou um simplesmente um outro cabeçalho \cite{vieira2007}.
 
 O HTTP é\textit{ stateless}, ou seja, ele não é capaz por si só de reter informações entre requisições diferentes. Para manter informações é necessário utilizar \textit{cookies}, sessões, campos de formulário ou variáveis na própria URL \cite{vieira2007}.
 
Quando um requisição é realizada, é preciso especificar qual método deve ser utilizado. O HTTP possui 8,  conhecidos por verbos, 
identificam a ação a ser executada por certo recurso.  Os 5 métodos mais utilizados são: \textit{get, post}, \textit{delete}, \textit{put} e \textit{head} \cite{vieira2007}\cite{szigalski2018}. 

\textit{Get} solicita a representação  de um recurso. É definido como um método seguro e não deve ser usado para disparar uma ação.  \textit{Post} é a informação enviada ao corpo da requisição e é utilizado para criar um novo recurso. \textit{Delete} remove um recurso. \textit{Put} atualiza um recurso na URI especificada. Caso o recurso não exista, ele pode criar um. A principal diferença entre \textit{post} e \textit{put} é que o primeiro pode lidar não somente com recursos, mas pode fazer processamento de informações, por exemplo. \textit{Head} retorna informações sobre um recurso. Na prática, funciona semelhante ao método \textit{get}, mas sem retornar o recurso no corpo da requisição. É considerado um método seguro \cite{vieira2007}.

Toda requisição recebe um código de resposta conhecido como \textit{status}.  Assim é possível saber se uma operação foi realizada com sucesso (código 200), se ele foi movida e agora existe em outro lugar (código 301) ou se não existe mais ( código 404), e existem diversos outros códigos \cite{vieira2007}.

O HTTP é um protocolo extensível que é simples de usar. A arquitetura cliente-servidor, combinada com a habilidade de simplesmente adicionar cabeçalhos, permite que o HTTP avance suas funcionalidades juntamente com a elasticidade da \textit{web} \cite{szigalski2018}.



\chapter[Metodologia]{Metodologia}

Nesta seção será apresentado quais foram os materiais e métodos utilizados para implementação do projeto, tanto da parte de \textit{hardware} (parte física) quanto a parte de \textit{software}. A principal metodologia utilizada foi baseada  no \textit{Scrum}, que é um método ágil iterativo incremental, onde o projeto foi divido em ciclos de 15 dias chamados de "\textit{sprints}". A cada \textit{sprint}, algumas atividades são retiradas do \textit{backlog}\footnote{Conjunto de requisitos que ainda não foram solucionados.}, colocadas no campo "\textit{do}"\footnote{Campo onde estão as atividades a serem realizadas durante a \textit{sprint}.}  e tem de ser resolvidas até o início da próxima \textit{sprint}, onde as atividade realizadas serão avaliadas,  validadas ou não, se estiverem atendendo ao requisito são enviadas para o "\textit{done}"\footnote{Conjunto de atividades que já foram feitas e validadas.}, se não estiverem atendendo as necessidades, elas voltam ao \textit{backlog} ou para o \textit{do}.

Os requisitos do projeto, que compuseram o \textit{backlog} e definiram os objetivos desse projeto foram relacionados com o auxílio dos pesquisadores do LIS e alunos de mestrado da UnB/FGA.

O trabalho foi divido em duas etapas, a primeira etapa foi focada em realizar a comunicação via porta serial  e com o microcontrolador Arduíno, com ele foram adquirido os parâmetros de um sensor MPU6050, em seguida foi realizada a multiplexação de 3 sensores para poder obter medidas de 3 pontos ao mesmo tempo através de um único Arduíno. A segunda etapa foi tentar comunicar o sensor com o computador por meio de transmissão sem fio e com protocolo HTTP, utilizando o ESP8266 e seu módulo de \textit{Wi-Fi}.
   
\section{Projeto de Hardware}

	\subsection{Materiais Utilizados}
		\begin{itemize}
			
			\item Sensor MPU6050;
			\item Arduíno Nano V.3;
			\item WeMos D1 -R2;
			\item Fios (\textit{jumpers});
			\item Cabo USB/Micro USB;
			\item Cabo USB/Mini USB;
			\item Computador com Arduíno IDE e \textit{Python} instalados;
			\item \textit{Jupyter Notebook};
			\item Tiras de velcro;
			\item Cabo \textit{flat} (8 fios);
			\item \textit{Protoboard};
			\item Placa de Cobre  Perfurada - 15x10cm;
			\item Bateria 5V - 2A -  conector - Mini USB .
		\end{itemize}	
	 
	\subsection{Métodos}
		
		Para realizar a comunicação do sensor MPU6050 com o Arduíno foi feita a conexão conforme o esquemático mostrado na Figura \ref{conexoes} e na Tabela \ref{conexoes_arduino}. Logo abaixo, onde os pinos Vcc e Gnd do MPU6050, responsáveis por ligar do sensor, foram conectados aos pinos 5V e Gnd do Arduíno. O pino SDA (\textit{Serial Data} - Dados Seriais)\footnote{Pino de transferência de dados.} foi conectado ao pino SDA do Arduíno, que também é o pino de entrada analógica A4 e o pino SCL (\textit{Serial Clock} - Sinal de "Relógio"\ Serial)\footnote{Pino de sincronização do \textit{clock}.} ao pino SCL do Arduíno, que é o pino de entrada analógica A5.  
		
		O  modelo escolhido para este projeto foi o Arduíno Nano, pois mesmo sendo apenas um protótipo, haverá a necessidade de que o tamanho do IMU seja reduzido para facilitar a fixação em diversas partes do corpo e o custo\footnote{Preços pesquisados em lojas de Brasília.} para desenvolvimento do protótipo foi levado em consideração.
		
		Para os primeiros testes foi utilizada uma \textit{protoboard} para facilitar as conexões, pois ela permite que os componentes sejam conectado sem a necessidade de solda entre eles. Mas em um segundo momento para os teste de movimento serem realizados com maior acurácia, houve a necessidade de retirar os componentes da \textit{protoboard} e soldá-los em uma placa furada de cobre, e isso faria o ruído devido a conexões instáveis fosse menor.
		
		O sensor foi fixado em uma faixa de velcro, para permitir a fixação do IMU em diversas partes do corpo, e para conectá-lo ao Arduíno foi soldado ao sensor um cabo \textit{flat} com 8 fios.
		
		\begin{table}[h!] \footnotesize
			\centering
			\caption{Conexões entre Arduíno e MPU6050}
			\label{conexoes_arduino}
			
			\begin{tabular}{cc}
				\toprule
				\textbf{Arduíno} & \textbf{MPU6050} \\
				\midrule
				5V & VCC \\
				GND & GND \\
				A4 & SDA \\
				A5 & SCL \\
				\bottomrule
			
			\end{tabular}
		\end{table}
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.5]{figuras/conexoes_mpu_arduino.PNG}
			\caption{ Esquemático de conexão do MPU6050 com Arduíno Nano (Imagem do autor).}
		 \footnotesize
			\label{conexoes}	
		\end{figure}
		
		A comunicação entre o sensor MPU6050 e o Arduíno foi realizada através do protocolo $I^2C$, onde os dados eram enviados de forma serial através de apenas um fio e os dados organizados como mostrado na Figura \ref{comunicacao}, onde é evidenciado quais são os dados transmitidos do MPU6050 para o Arduíno e a velocidade do \textit{clock}, e Figura \ref{i2c}, que mostra com mais detalhe a relação dos dados com o \textit{clock}.
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=1]{figuras/comunicacao.PNG}
			\caption{ Transmissão de dados do MPU6050 para Arduíno (Imagem do autor).}
		 
			\label{comunicacao}	
		\end{figure}
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.5]{figuras/i2c.PNG}
			\caption{Transferência de dados com o protocolo $I^2C$. }
			Fonte: \cite{mpu6050}. 
			\label{i2c}	
		\end{figure}
	
		O Arduíno Nano foi conectado ao computador por meio de um cabo USB 2.0, que além de ser responsável pela comunicação, também era por meio dele que era realizada a alimentação de energia com 5V de tensão. O protocolo de comunicação utilizado com um cabo USB  foi o serial. Então, os dados transmitidos do Arduíno para o computador são enviados em série. 
		
		Ainda na primeira etapa foi realizada a montagem utilizando 3 sensores.  Para isso foi preciso adicionar mair um pino do MPU6050 a montagem, para poder realizar a multiplexação deles. Foi utilizado o pino AD0, responsável por definir um nome de endereço para o sensor. Quando o é conectado com 0 V (Nível Lógico Baixo), o seu endereço de registrador se torna 0x68, e quando ligado entre 3.3 e 5 V (Nível Lógico Alto), é alterado para 0x69.  Dessa forma foi possível realizar a leitura dos sensores de forma sequencial. A tabela \ref{conexoes_mult} mostra as conexões necessárias.
		
		 	\begin{table}[h!] \footnotesize
		 	\centering
		 	\caption{Conexões entre Arduíno e 3 Sensores }
		 	\label{conexoes_mult}
		 	
		 	\begin{tabular}{cccc}
		 		\toprule
		 		\textbf{Arduíno} & \textbf{MPU6050 A} & \textbf{MPU6050 B} & \textbf{MPU6050 C} \\
		 		\midrule
		 		5V & VCC & VCC & VCC  \\
		 		GND & GND & GND & GND\\
		 		A4 & SDA & SDA & SDA  \\
		 		A5 & SCL & SCL & SCL \\
		 		D2 & AD0 & - & - \\
		 		D3 & - & AD0 & - \\
		 		D4 & - & - & AD0 \\
		 		\bottomrule
		 	%	Fonte: & autoria própria
		 	\end{tabular}
		 \end{table}
	 
	 Para a segunda etapa, foi escolhido a placa Wemos D1,  como apresentado no referencial teórico, todas as placas que possuem o processador ESP8266 apresentam características  semelhantes, a Wemos foi escolhida pela possibilidade de conectá-la ao computador sem a necessidade de um cabo USB, após configurar o \textit{firmware} para criar uma conexão \textit{wireless}, ou se conectar a uma rede. 
	 
	 A Tabela \ref{conexoes_esp} mostra a conexão do MPU6050 com a ESP8266, a qual,  é semelhante à primeira montagem realizada com o Arduino, sendo alterado apenas o nome dos pinos que representam SCL e SDA, na Wemos, que são, respectivamente, os pinos digitais D1 e D2.
	  
	 \begin{table}[h!] \footnotesize
	 	\centering
	 	\caption{Conexões entre Wemos e Sensor  }
	 	\label{conexoes_esp}
	 	
	 	\begin{tabular}{cc}
	 		\toprule
	 		\textbf{Wemos D1} & \textbf{MPU6050} \\
	 		\midrule
	 		5V & VCC \\
	 		GND & GND \\
	 		D2  & SDA  \\
	 		D1 & SCL \\
	 		\bottomrule
	 		%Fonte: & autoria própria
	 	\end{tabular}
	 \end{table}
 
 Foi necessário para carregar o código do \textit{firmware}, a conexão do Wemos através do cabo micro USB, após o programa ser compilado e salvo no microcontrolador, este foi desconectado já com o sensor ligado a ele e foi adicionada uma bateria de 5V, 2A e carga de 10000 mAh, para fornecer energia à placa. Essa fonte garante  energia suficiente para placa configurada como ponto de acesso e o sensor. O consumo energético máximo do MPU6050 é 3,9 mA e da placa Wemos é de   215 mA, logo o essa bateria, estando totalmente carregada, garante a utilização do conjunto por mais de 4 horas.  
 
\section {Projeto de \textit{Software}}
		
		Para esse trabalho foram necessários seis projetos de \textit{softwares}, dois para Arduíno, uma para o Wemos,  dois em \textit{Python}, responsáveis por realizar o tratamento dos dados adquiridos do sensor e salvá-los para análises futuras e um terceiro apenas para testar a comunicação sem fio e verificar a velocidade da transmissão.
		
		\subsection{\textit{Software}s para o Arduíno}
			
			Os requisitos do \textit{software} salvo no microcontrolador, conectado com apenas um sensor, são:
			
			\begin{itemize}
				\item Inicializar o MPU6050;
				\item Receber os dados do MPU6050; 
				\item Enviar os dados para interface serial.
			\end{itemize}
		
		Para isso foram utilizadas as bibliotecas \textit{Wire.h}, \textit{I2Cdev.h} e \textit{MPU6050.h}, que são responsáveis por realizar a comunicação em $I^2C$, enviar o comando de inicialização, a variável escolhida pelo usuário para definir os limites de leitura do acelerômetro e do giroscópio. São estas bibliotecas que realizam a leitura dos registradores que tem o valor de cada sensor armazenado neles.  
		
		O fluxograma do \textit{software} responsável pela leitura dos dados do MPU6050 e envio para a \textit{interface} de comunicação serial é o mostrado na Figura \ref{fluxograma_arduino}. 
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.9]{figuras/diagrama_embarcado.PNG}
			\caption{Fluxograma do \textit{software} de leitura dos dados. (Imagem do autor).} 
			\label{fluxograma_arduino}	
		\end{figure}
		
		Para realizar a transmissão dos dados do Arduíno para o programa em \textit{Python}, o programa salvo no Arduíno imprime no terminal serial os dados obtidos do sensor. O programa é fechado sempre que uma nova leitura é realizada.
		
		O código feito para conectar o Arduíno a 3 sensores e transmitir os dados adquiridos, foi feito sem o auxílio de todas as bibliotecas utilizadas no anterior, pois esse precisa de uma velocidade de processamento mais alta, para não perder a qualidade do sinal. 
		
		São configurados os pinos D2, D3 e D4 como saídas digitais, estes serão os pinos que definirão qual sensor está estabelecendo comunicação. Em seguida D2 é alterado para o estado \textit{LOW } (nível lógico baixo), e outros dois permanecem em nível lógico alto e o sensor conectado ao pino D2 é inicializado. Esse mesmo procedimento é realizado com nos pinos D3 e D4, assim todos os sensores têm comunicação iniciada.
		
		Dentro da função \textit{loop}, foi implementado mais um laço  para realizar multiplexação e alterar o identificador do sensor. Nessa função os sensores são lidos um e enviados ao terminal serial a cada execução do laço. Foi colocada uma função \textit{timer}, para garantir a frequência de 1kHz na leitura dos sensores.

\subsection{\textit{Software} para o Wemos D1}

	O \textit{software} ou \textit{firmware} do microcontrolador ESP8266,  precisa de uma biblioteca específica para ele poder ser escrito na IDE do Arduíno, a ESP8266WiFi.h, responsável pela configuração do módulo \textit{wireless}. 
	
	O código primeiro configura o módulo como servidor \textit{Wi-Fi} habilitando a porta 80.  A variáveis são inicializadas e dentro da função \textit{setup} e são iniciados os modos de comunicação serial e \textit{wire},  o sensor MPU6050 é ligado e configurado para transmissão  dos parâmetros de movimento. 
	
	Os endereços para utilização do protocolo HTTP são escritos,  o microcontrolador é configurado como ponto de acesso, seu nome e senha são salvos. E os endereços escritos anteriormente são salvos nas configurações do módulo.

	A transmissão \textit{wireless} é habilitada antes da execução da função \textit{loop}, a qual fica na espera a requisição de um cliente para iniciar leitura e transmissão dos dados ao endereço de IP configurado no início do programa. Assim que a requisição é feita é verificado se o endereço requisitado é estabelecido, se for é escrito o código 200, para confirmar que foi um comunicação bem sucedida e os dados então são escritos.
	
	Em seguida o programa volta a esperar mais uma requisição para ler e enviar os dados.
		 
\subsection{\textit{Software} para Salvar os Dados}

		Esse programa, foi feito para realizar a leitura dos dados transmitidos pelo Arduíno, e salvá-los em um arquivo de texto, para futuras análises. Esse \textit{software} ainda dá a possibilidade do usuário salvar os dados sem nenhum tratamento ou os valores com medidas físicas aproximadas das medições realizadas. 
		
		O \textit{software} foi escrito em \textit{Python} 3 e interpretado com o \textit{Jupyter Notebook} e com a IDE \textit{Spyder}, os dois programas são do pacote \textit{Anaconda}. 
		
		O programa inicia mostrando a lista de dispositivos USB conectados ao computador. Se não houver nenhum dispositivo conectado aparece a mensagem "Conecte o Arduíno". Se houver, a mensagem que aparece pede para digitar o número correspondente ao dispositivo que o usuário pretende verificar os dados. 
		
		Após a escolha do Arduíno, o usuário deve escolher entre as 4 possibilidades de escala dos dados obtidos. E em seguida pressionar " \textit{enter}"\ para iniciar a leitura e "Ctrl+C"\footnote{No \textit{Jupyter Notebook} o "Ctrl+C"\ não funcionou, precisando assim pressionar o ícone de \textit{"stop"} disponível na tela.} para pausar e salvar os valores. O programa então imprime na tela os valores dos sensores que estão sendo lidos e ao fim do código, quando o usuário pressionar "I"\ duas vezes, os valores são salvos em dois arquivos nomeados com a data de quando foi finalizada a leitura, como mostrado na Figura \ref{fluxograma_python}.
		
		Para definir melhor os requisitos do \textit{software}, foi feita a seguinte história de usuário descrita na Tabela \ref{User_story}, e a partir dela foi possível desenvolver o \textit{software} inicial e com ele realizar os testes preliminares do protótipo.
		
			\begin{table}[h!] \footnotesize
			\centering
			\caption{História de Usuário}
			\label{User_story}
			
			\begin{tabular}{ccl}
				\toprule
				\textbf{Usuário} & \textbf{O que quer fazer?} & \textbf{Resposta do Sistema} \\
				\midrule
				Pesquisador & Inicializar o sistema &  Abre o \textit{prompt} de comando \\
				 & & Mostra a lista de dispositivos conectados \\
				Pesquisador & Selecionar o sensor & Estabelecer a conexão com sensor \\
				& & Mostra a lista de intervalo de leitura\\
				Pesquisador & Selecionar o intervalo & Mensagem de qual intervalo foi selecionado\\
				& & Aguarda comando para iniciar a coleta\\
				Pesquisador & Iniciar coleta & Inicia a coleta\\
				& &  Aguarda comando para pausar coleta\\
				Pesquisador & Pausar coleta e salvar Dados & Para a coleta\\
				& & Fecha a conexão\\
				& & Salva os dados coletados\\
				& & Mensagem com nome dos arquivos\\  
 				
				\bottomrule
				% & & Fonte: autoria própria
			\end{tabular}
		\end{table}
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=1]{figuras/diagrama_python.PNG}
			\caption{Fluxograma do \textit{software} que salva os dados lidos (Imagem do autor).}
		 
			\label{fluxograma_python}	
		\end{figure}
		
		O segundo \textit{software} em \textit{Python} foi escrito para receber os dados de 3 sensores. Esse programa funciona basicamente da mesma forma que o primeiro, com as seguintes  diferenças:  recebe um dado a mais a cada laço de execução, o número de identificação do sensor que varia de 1 a 3; possui uma variável a mais para  armazenar esse valor; não exibe a escolha de escalas de medição diferentes; e no fim da execução pergunta ao usuário se deseja salvar os dados ou não.

\subsection{\textit{Software} para Teste de Comunicação Sem Fio}

	Esse código foi escrito apenas para receber os dados do escritos pelo Wemos no endereço especificado e verificar o tempo que de duração entre cada requisição.
	
	O programa utilizou a biblioteca a \textit{urllib}, para realizar a requisição; a 'bs4' para salvar apenas os dados transmitidos, e não os provenientes do protocolo HTTP; e a \textit{timeit} para calcular o tempo de execução do código.
	
	Era executado um laço, que realiza a requisição, salva e imprimi o texto recebido, durante a execução do laço um variável armazenar o número de vezes que o laço foi executado. Para interromper o programa o usuário precisa pressionar a tecla 'I' duas vezes. 
	
	Após a interrupção é calculado o tempo médio de execução de cada laço. Esse valor, o tempo total e número de execuções são impressos  no terminal.

\section {Teste}

	Para testar o funcionamento dos acelerômetros do IMU foi feito um teste simples. Pois sempre que o sensor estiver "parado", ele estará sobre efeito da força do peso e consequentemente da aceleração da gravidade de aproximadamente 9,8 m/$ s^2 $. Então para verificar, foi necessário testar o sensor com um eixo de cada vez alinhado com a Normal, como na Figura \ref{acel_validation}, onde a imagem mais à direita mostra o MPU6050 com do eixo X paralelo a Normal, a imagem à direita com o eixo Y paralelo a Normal e ao centro o eixo Z.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.8]{figuras/validacao_acel.PNG}
		\caption{Demonstração da posição do sensor (Imagem do autor).}
		 
		\label{acel_validation}	
	\end{figure}
	
	Após realizar as leitura, os dados foram plotados em um gráfico simples, onde o eixo horizontal representa o tempo e o vertical a aceleração medida. Foram colocados os gráficos dos 3 eixos na mesma imagem. 
	
	Para verificar se os giroscópios estavam funcionando, sem ainda se atentar a precisão deles e confiabilidade das medidas, foi realizado um movimento de rotação de 90$ \degree $ em relação a cada um dos eixos, como na Figura \ref{validacao_giro}  e ao fim da leitura do sensor o resultado foi plotado em um gráfico para facilitar a análise.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.55]{figuras/validacao_giro.png}
		\caption{Demonstração direção de giro do sensor (Imagem do autor).}
	
		\label{validacao_giro}	
	\end{figure}
	
	Para testar o funcionamento do programa que recebia os dados do 3 sensores multiplexados, o programa foi executado e os foi verificado o tempo transcorrido durante a execução do programa e o resultado foi dividido pelo total de execuções. Para verificar se a velocidade de processamento era suficiente para garantir o que o dados representam os parâmetros reais.
	
	O funcionamento da transmissão sem fio foi monitorado ligando a placa Wemos à bateria, conectando o computador a rede \textit{wireless} gerada pela placa. Em seguida o programa feito em Python foi executado em a diferentes distâncias entre a placa e computador conectado a ela, para verificar a perda de velocidade de processamento com o distanciamento.
	
	Para confirmar o funcionamento do MPU6050  e se as leituras são confiáveis, ou não, serão necessários outros testes além dos realizados até o momento, como a comparação dos valores obtidos medindo os parâmetros que descrevem os movimentos ao mesmo tempo que uma gravação de vídeo é realizada, e verificar se os valores obtidos com o IMU são condizentes com as imagens gravadas. 
	
	Este trabalho teve aprovação do comitê de ética CAAE (Certificado de Apresentação para Apreciação Ética) número: 82432618.1.0000.8093. 
	
	%Uma vez que havia necessidade de realização de testes em seres humanos, foi necessária a aprovação dessa coleta por um comitê de ética. 
	
	E para validar a medição do sensor com fim de  utilizá-lo em pesquisas com movimento musculoesqulético humano é necessário ao menos um estudo de caso.
	
\chapter{Resultados e Discussão}
	\section{Resultados}
	
	
	Os resultados obtidos são os seguintes: protótipo funcional, \textit{software} para o microcontrolador, \textit{software} para ler, tratar e salvar os dados, tabelas e gráficos parciais do funcionamento do IMU. Os códigos aqui desenvolvidos estão disponibilizados nos Apêndices \ref{apA}, \ref{apB}, \ref{apC}, \ref{apD}, \ref{apE}, \ref{apF} e \ref{apG}.
	
	
	As Figuras \ref{prototipo1} e \ref{prototipo1_2} mostram a primeira montagem feita do IMU para programar o microcontrolador e verificar a comunicação entre o sensor e o Arduíno. As Figuras \ref{prototipo2} e \ref{prototipo3} mostram a segunda montagem realizada do IMU, onde ele foi soldado com um cabo \textit{flat} e preso em uma tira de velcro.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.12]{figuras/prototipo1.jpg}
		\caption{Protótipo na \textit{Protoboard} (Imagem do autor).}

		\label{prototipo1}	
	\end{figure}
	 
	 	\begin{figure}[h!]
	 		\centering
	 		\includegraphics[keepaspectratio=true,scale=0.12]{figuras/prototipo2.jpg}
	 		\caption{MPU6050 na \textit{Protoboard} (Imagem do autor).}
	 		
	 		\label{prototipo1_2}	
	 	\end{figure}
	 	
	 	\begin{figure}[h!]
	 		\centering
	 		\includegraphics[keepaspectratio=true,scale=0.12]{figuras/prototipo_2_1.jpg}
	 		\caption{Segundo Protótipo com o Velcro (Imagem do autor).} 
	 		\label{prototipo2}	
	 	\end{figure}
	 	\begin{figure}[h!]
	 		\centering
	 		\includegraphics[keepaspectratio=true,scale=0.1]{figuras/prototipo_2_2.jpg}
	 		\includegraphics[keepaspectratio=true,scale=0.1]{figuras/prototipo_2_3.jpg}
	 		\caption{Protótipo Fixado ao Punho e a um Cubo (Imagem do autor).} 
	 		\label{prototipo3}	
	 	\end{figure}
	 
	O programa em funcionamento é mostrado nas Figuras \ref{tela_inicial}, \ref{lista_ranges} e \ref{rodando} que, por enquanto, apenas no \textit{prompt} de comando. A Figura \ref{tela_inicial} mostra a mensagem que aparece assim que a pessoa coloca o programa para funcionar, no caso, aparece também a lista de dispositivos conectados e pede para a pessoa escolher um deles. Se nenhum estivesse conectado, apareceria a mensagem "Conecte o Arduíno".
	
	A Figura \ref{lista_ranges} mostra o que aparece logo depois de escolher o Arduíno. A confirmação de conexão com Arduíno, uma mensagem, que vem do próprio Arduíno, pedindo para selecionar uma das opções mostradas logo abaixo em um lista de possíveis escalas de leitura para o IMU e aguarda a escolha do usuário.
	
	E na Figura \ref{rodando}, aparece a mensagem para iniciar a leitura do sensor e alguns dos dados lidos são mostrados para o usuário, precisando apenas pressionar 'I' duas vezes para pausar a leitura e salvar os dados em dois arquivos. Apenas para os testes foram acrescentados ao final do programa a geração de dois gráficos, um com os dados obtidos dos acelerômetros e o outro para o giroscópio. 
	 	
	 	\begin{figure}[h!]
	 		\centering
	 		\includegraphics[keepaspectratio=true,scale=0.5]{figuras/tela_inicial.png}
	 		\caption{Tela Inicial (Imagem do autor).}
	 	
	 		\label{tela_inicial}	
	 	\end{figure}
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.5]{figuras/lista_ranges.png}
		\caption{Lista com as escalas (Imagem do autor).}
		
		\label{lista_ranges}	
	\end{figure}
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.5]{figuras/programa_rodando.png}
		\caption{Programa mostrando os resultados (Imagem do autor).}
	
		\label{rodando}	
	\end{figure}
	
		
	Os gráficos apresentados na Figura \ref{acelx_0}, mostram o resultado parcial do teste para medir a aceleração da gravidade com cada um dos 3 acelerômetros. É possível a partir deles verificar que os acelerômetros estão obtendo valores realistas para as medidas feitas, pois todos os gráficos apresentaram um valor próximo ao da aceleração da gravidade. Os gráficos ainda não estão com aspecto ideal, dando a sensação de presença de ruído, mas isso pode ser corrigido com um \textit{buffer} para carregar uma quantidade de valores e mostrar apenas a média deles, porque o sensor é sensível a pequenas variações de aceleração.   
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.6]{figuras/graficos_acel.png}
		\caption{Gráficos com os 3 Eixos alinhados com a Normal. (Imagem do autor).}
		Na imagem à esquerda o Eixo X está alinhado, à direita o Eixo Y e ao centro o Eixo Z. \footnotesize 
		\label{acelx_0}	
	\end{figure}		
	
	Os gráficos da Figura \ref{teste_giro} representam à esquerda, à direita e ao centro, respectivamente, a rotação em relação aos Eixos X,Y e Z. O gráfico apresenta vários picos e variações que parecem ruidosos, mas na realidade é porque o sensor é  preciso o bastante para captar pequenos impactos. E na hora de realizar o teste precisava de uma movimentação mais suave e constante, para melhor visualização no gráfico, mas como o teste foi realizado movimentando o sensor com a mão, ele captou a vibração natural da mão e o impacto com a superfície no momento que ele é solto, o que explica a movimentação em todos os sensores e não apenas em um.
	
	Porém, mesmo com o gráfico não apresentando o resultado ideal, é possível verificar a variação nas velocidades de rotação em cada giroscópio separadamente, o que demonstra que os giroscópios funcionam. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.7]{figuras/teste_giro.png}
		\caption{Gráficos para Teste do Giroscópio (Imagem do autor).}
		\label{teste_giro}	
			    
	\end{figure}
	
			Foi obtido como resultado, também, a montagem da placa formada pelo Arduíno, cabos \textit{flat } e os 3 sensores vistos nas Figuras \ref{placa} , \ref{cabo} e \ref{mult}. O cabo \textit{flat} utilizado nesses sensores, não foi soldado, como  o primeiro utilizado, e sim \textit{crimpado}. Dessa forma ele ficou menos sensível a movimentação. O que havia sido soldado, acabou quebrando após algumas utilizações. 
		
		\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.075]{figuras/placa_furada.jpg}
			\caption{Placa Perfurada (Imagem do autor).}
			
			\label{placa}	
		\end{figure}
	
			\begin{figure}[h!]
			\centering
			\includegraphics[keepaspectratio=true,scale=0.075]{figuras/cabo_mpu.jpg}
			\caption{Cabo Flat com Sensor (Imagem do autor).}
		
			\label{cabo}	
		\end{figure}
		
		\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.075]{figuras/multiplexados.jpg}
		\caption{3 sensores Multiplexados (Imagem do autor).}
		
		\label{mult}	
	\end{figure}
	
	O resultado do fim da execução do programa utilizando os 3 sensores foi o mostrado na figura \ref{exec3}. O início do programa é parecido com o primeiro. O resultado obtido foi mostrado em relação ao tempo de execução em segundos e foi igual a 0,00235 s. Sabendo que $f = 1/s$ então $ f = 425,5 Hz $ .
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.6]{figuras/execut_3s.png}
		\caption{Final da Execução dos 3 Sensores (Imagem do autor).}
		
		\label{exec3}	
	\end{figure}
	
	Seriam gerados, como resultado, os gráficos de cada um dos sensores. Não foi implementado porque antes de escrever esta parte do código, a qual exigia algumas manipulações nos dados, foi iniciada a segunda etapa do projeto. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.075]{figuras/wemos1.jpg}
		\caption{Wemos com Sensor MPU6050 (Imagem do autor).}
		
		\label{wemos1}	
	\end{figure}
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.075]{figuras/wemos2.jpg}
		\caption{Wemos Configurada como Ponto de Acesso WiFi (Imagem do autor).}
	 
		\label{wemos2}	
	\end{figure}
	
	Os últimos resultados obtidos foram o sensor conectado à placa Wemos, a comunicação sem fio (Figura \ref{wemos1} e \ref{wemos2}), a alimentação por bateria recarregável, a execução do programa para obtenção dos dados (Figura \ref{exechtml}) e a frequência de execução do código.
	
		\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.6]{figuras/execute_html.png}
		\caption{Final da Execução da Leitura  Sem Fio (Imagem do autor).}
		
		\label{exechtml}	
	\end{figure}
	
	
	A Figura \ref{exechtml} mostra o final da execução do programa quando a distância entre a placa Wemos e o computador era de 1 metro.  Para ficar mais clara a essa variação, foi feito o gráfico mostrado na Figura \ref{grafico}, onde o eixo x representa a distância e o eixo y a frequência calculada com os intervalos de  tempo obtidos após cada execução.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[keepaspectratio=true,scale=0.8]{figuras/frequenciaXdist.png}
		\caption{Frequêcia x Distância (Imagem do autor).}
		\label{grafico}	
	\end{figure}
	
	A frequência atingida através da conexão sem fio não atingiu a taxa de Nyquist para amostragem do movimento humano, mostrado no referencial teórico. E quanto maior a distância entre o transmissor e receptor, menor foi a frequência obtida. Com esse resultado o sinal a ser amostrado pode ter uma frequência máxima de 40Hz.
	
	\section{Discussão}		

	O primeiro protótipo, na \textit{protoboard}, foi útil por facilitar os testes de conexão, pois com a \textit{protoboard} não era necessário soldar os pinos, mas por ser uma conexão instável está propensa a ruídos. E por isso foi feito o segundo protótipo. O cabo \textit{flat} foi escolhido por permitir soldar o sensor e ainda mantê-lo com um tamanho confortável para fixação.
	
	A \textit{interface} do programa ainda precisa ser melhorada, mas atende a aplicação, porque foi feita para utilização de pesquisadores do laboratório que receberam o treinamento e saberão lidar com linhas de comando, ou receberão o treinamento necessário para a devida utilização. Com a melhoria da \textit{interface}, será mais intuitivo utilizar o programa e ele se tornará ainda mais acessível, podendo ser utilizado por outros profissionais que tiverem interesse no movimento humano.
	
	 A partir dos resultados preliminares, mostrados nos gráficos, é possível verificar que o IMU com fio e comunicação serial, pode ser utilizado  para o propósito estabelecido inicialmente, porém, este construído ainda é apenas um protótipo, vários testes ainda serão necessários. Os gráficos ficariam melhores se os testes não tivessem sido realizados com os métodos que foram utilizados, onde, o sensor acabou medindo a movimentação da mão que o manipulou, tornando o movimento irregular, e também acabou medindo os impactos sobre o mesmo.
	
	A multiplexação dos sensores através do próprio \textit{firmware} do Arduíno, se mostrou viável para utilização, pois a frequência obtida estava dentro da Taxa de Nyquist, porém ainda necessita de otimização devido estar próxima da frequência mínima;
	
	O comunicação sem fio foi estabelecida, os dados são todos transmitidos e com uma boa velocidade, mas não suficiente para esta aplicação.  Provavelmente essa taxa de transmissão que foi atingida pode ser elevada a uma frequência muito mais alta. Os dados foram transmitidos em forma de \textit{String} (um vetor de caracteres), cada caractere ocupa 1 \textit{byte}. esse vetor que estava sendo transmitido possui um tamanho variável entre 7 e \textit{ bytes}. Os dados obtidos através do sensor são enviados no barramento $I^2C$ através de um vetor de inteiros com 14 \textit{bytes}. Portanto, conseguindo transmitir os dados com mesmo formato que eles são obtidos, haveria um ganho na taxa de transmissão e processamento.
	
\chapter{Conclusão}
	
	A medição dos movimentos  humanos é bem importante para estudos sobre prevenção de lesão em atletas, correção de postural e outros tratamentos fisioterápicos. Para realizar essas medições são necessários equipamentos específicos. E o IMU surge como uma solução viável para facilitar o acesso dos pesquisadores a sensores de utilização menos complexas e de custo mais baixo. 
	
	Foi concluído, neste trabalho, o protótipo de um sensor IMU capaz de medir a aceleração linear em três eixos, e a velocidade angular em três eixos. Os parâremtros que podem ser calculados com esse dados são velocidade linear, deslocamento e ângulos em relação aos 3 eixos. É possível utilizar mais de um sensor conectado a um único microcontrolador para obtenção dos parâmetros de movimento em até 3 pontos de interesse simultaneamente com a multiplexação dos canais de entrada. A partir dos resultados obtidos é possível afirmar que os sensores podem ser utilizados para realizar coleta de parâmetros de movimento. Sendo necessário validar os dados obtidos através do sensor, o que não foi o objetivo desse trabalho.
	
	A comunicação sem fio pode ser útil para utilização do sensor com maior grau de liberdade de movimentos, mas o protocolo utilizado nesse projeto ainda não é o ideal, devendo ser otimizado para realização de coletas mais precisas. 
	
	Como proposta para trabalhos futuros fica a validação dos dados obtidos, podendo ser realizado um estudo de caso e comparação de resultados com outros mecanismos de medição que já tem sua acurácia comprovada. A otimização do protocolo de comunicação sem fio e do sistema de multiplexação para que permita a utilização de mais de 3 sensores em uma única coleta. Melhorar a \textit{interface}  para uso de profissionais de diversas áreas. E tentar tornar o IMU mais miniaturizado, tentando integrar uma única placa o transmissor sem fio, o microcontrolador e o sensor de movimento.